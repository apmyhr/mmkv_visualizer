<!DOCTYPE html>
<html>
  <head>
      <script src="https://cdn.jsdelivr.net/pyodide/v0.20.0/full/pyodide.js"></script>
  </head>
  <body>
    <h1>Pyodide test page</h1>
    Open your browser console to see Pyodide output
    <script type="text/javascript">
      async function setupPyodide() {
        // Setup "pyodide" and have it be global
        let pyodide = await loadPyodide();
        console.log('[+] Finished setting up Pyodide')

        pyodide.runPython(`
          from io import BufferedIOBase, BytesIO
          from pathlib import Path
          from typing import Optional, List, Tuple
          from collections import defaultdict

          import sys
          import struct
          import ctypes

          def decode_varint(buffered_base: BufferedIOBase, mask: int = 64) -> Tuple[int, int]:
            """
            Reads a base-128 varint from 'buffered_base' and returns the positive result of the
            varint.
            This assumes a 'mask' of 64-bits for decoding typical "int32" and "int64" values,
            but should pass in a mask of 32-bits when decoding varints that denote lengths.
            """
            shift = 0
            result = 0
            bytes_read = 0
            byte = buffered_base.read(1)
            bytes_read += 1

            # Check if 'buffered_base' has valid bytes
            if not byte:
                print('[+] buffered_reader has no more bytes to read. Most likely trying to decode'
                      ' data that is not a varint.')
                return -1, -1

            # Iterate through 'buffered_base' and varint
            while True:
                i = struct.unpack('B', byte)[0]

                # Prepare the result by ANDing the lower 7-bits and shifting for every byte read
                result |= (i & 0x7f) << shift
                shift += 7
                if not (i & 0x80):
                    # AND the value to keep it within 'mask' range
                    result &= ((1 << mask) - 1)
                    break

                byte = buffered_base.read(1)
                bytes_read += 1

            return result, bytes_read


          def decode_signed_varint(buffered_base: BufferedIOBase, mask: int = 64) -> Tuple[int, int]:
              """
              Reads a base-128 varint from 'buffered_base' and returns the negative result of the
              varint.
              This assumes a 'mask' of 64-bits for decoding typical "int32" and "int64" with negative values.
              """
              shift = 0
              result = 0
              bytes_read = 0
              byte = buffered_base.read(1)
              bytes_read += 1

              # Check if 'buffered_base' has valid bytes
              if not byte:
                  print('[+] buffered_reader has no more bytes to read. Most likely trying to decode'
                        ' data that is not a varint.')
                  return -1, -1

              # Iterate through 'buffered_base'
              while True:
                  i = struct.unpack('B', byte)[0]

                  # Prepare the result by ANDing the lower 7-bits and shifting for every byte read
                  result |= (i & 0x7f) << shift
                  shift += 7
                  if not (i & 0x80):
                      result &= (1 << mask) - 1
                      if mask == 64:
                          result = ctypes.c_int64(result).value
                      else:
                          result = ctypes.c_int32(result).value
                      break

                  byte = buffered_base.read(1)
                  bytes_read += 1

              return result, bytes_read

          data = BytesIO(bytes.fromhex('ffffffff07'))
          print(data.getvalue())

          print(decode_varint(data))
        `);
      }

      let pyodide = setupPyodide()

    </script>
  </body>
</html>